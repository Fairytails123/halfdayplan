<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Half Day Route</title>

  <style>
    :root {
      --line: #6d8fb0;
      --lineW: 2px;
      --bg: #ffffff;
      --panel: #f6f7f9;
      --muted: #5b6470;
      --ui: #eef1f5;
      --accent: #2c5282;
      --danger: #e53e3e;
      --success: #2f855a;
    }

    * { 
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html {
      overflow-x: hidden;
    }

    /* ANDROID FIX: Allow default touch actions on body - MUST be auto */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: var(--panel);
      color: #111;
      min-height: 100vh;
      width: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      touch-action: auto;  /* CRITICAL: Must be auto for Android scroll */
      -webkit-user-select: none;
      user-select: none;
    }

    .page {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px;
      display: grid;
      gap: 12px;
    }

    .topbar {
      background: var(--bg);
      border-radius: 10px;
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    input[type="text"] {
      flex: 1 1 150px;
      min-width: 0;
      padding: 10px 12px;
      border-radius: 8px;
      border: 2px solid #e2e8f0;
      font-size: 16px;
      -webkit-user-select: text;
      user-select: text;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(44, 82, 130, 0.15);
    }

    button {
      padding: 10px 12px;
      border-radius: 8px;
      border: 2px solid transparent;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: bold;
      white-space: nowrap;
      transition: all 0.2s ease;
    }

    button:active { transform: translateY(1px); }

    .btn-danger { background: #fff5f5; border-color: var(--danger); color: var(--danger); }

    .tray-area {
      display: flex;
      gap: 8px;
      min-height: 60px;
    }

    .tiles-tray {
      flex: 1;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
      padding: 8px;
      min-height: 50px;
      border: 2px dashed #cbd5e0;
      border-radius: 8px;
      background: #f8fafc;
      transition: all 0.2s;
    }

    .tiles-tray.drag-over {
      border-color: var(--accent);
      background: #ebf8ff;
    }

    #bin {
      width: 50px;
      min-width: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fed7d7;
      border: 2px dashed #fc8181;
      border-radius: 8px;
      color: #c53030;
      font-size: 24px;
      flex-shrink: 0;
      transition: all 0.2s;
    }

    #bin.drag-over {
      background: #c53030;
      border-style: solid;
      transform: scale(1.05);
    }

    /* Tiles - touch-action:none enables long-press drag on Android */
    /* Scrolling works by touching page background, not tiles */
    .tile, .tile-inbox {
      background: #fff;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: grab;
      touch-action: none;  /* Enables long-press drag on Android */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      z-index: 100;
      word-break: break-word;
      line-height: 1.1;
      overflow: hidden;
      transition: box-shadow 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
      font-weight: 500;
    }

    /* Touch-active state - immediate feedback when touching tile */
    .tile.touch-active, .tile-inbox.touch-active {
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0.9;
    }

    /* Long-press active state - drag is starting */
    .tile.long-press-active, .tile-inbox.long-press-active {
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      opacity: 0.5;
    }

    /* Hover states - ONLY for mouse devices */
    @media (hover: hover) and (pointer: fine) {
      .tile:hover, .tile-inbox:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }
    }

    .tile {
      min-width: 80px;
      min-height: 38px;
      padding: 4px 6px;
      border: 2px solid #e2e8f0;
    }

    .tile:active { cursor: grabbing; }

    .tile-inbox {
      width: 100%;
      min-height: 32px;
      padding: 2px 3px;
      border: 1px solid #e2e8f0;
      background: linear-gradient(135deg, #fff 0%, #f7fafc 100%);
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }

    .layout-card {
      background: var(--bg);
      border-radius: 10px;
      padding: 12px;
      width: 100%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .title-centre {
      text-align: center;
      font-weight: 700;
      font-size: 16px;
      margin: 2px 0 10px 0;
    }

    .card-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 8px 0;
    }

    .van-section {
      margin-bottom: 16px;
    }

    .two-cols {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: start;
    }

    .section {
      display: grid;
      gap: 4px;
      min-width: 0;
    }

    .section-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 2px;
    }

    .section-head .label {
      font-weight: 700;
      font-size: 13px;
      color: #111;
    }

    .kennel-grid {
      border: var(--lineW) solid var(--line);
      background: #fff;
      width: 100%;
    }

    .row { 
      display: grid; 
      width: 100%;
    }

    .box {
      border: var(--lineW) solid var(--line);
      min-height: 75px;
      position: relative;
      padding: 2px;
      background: #fff;
      transition: background 0.2s, border-color 0.2s;
    }

    .box.drag-over {
      background: #ebf8ff;
      border-color: var(--accent);
    }

    .box-layout {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-rows: 22px 1fr;
      gap: 4px;
      padding: 3px;
    }

    .box-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      min-width: 0;
    }

    .stop-input {
      width: 36px;
      min-width: 36px;
      height: 20px;
      border: 1px solid #c9cdd3;
      border-radius: 4px;
      padding: 0 4px;
      font-size: 11px;
      background: #fff;
      -webkit-user-select: text;
      user-select: text;
      touch-action: manipulation;
      flex-shrink: 0;
    }

    .route-select {
      height: 20px;
      border: 1px solid #c9cdd3;
      border-radius: 4px;
      padding: 0 2px;
      font-size: 10px;
      background: #fff;
      min-width: 0;
      flex: 1;
      touch-action: manipulation;
    }

    .tile-area {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 4px;
      justify-content: center;
      align-items: stretch;
      padding: 2px;
      position: relative;
      min-height: 40px;
    }

    .tile-area.one .tile-inbox {
      width: 100%;
      height: 100%;
    }

    .tile-area.two .tile-inbox {
      width: 100%;
      height: calc(50% - 2px);
    }

    .wheel-obstruction {
      position: absolute;
      bottom: 3px;
      width: 32px;
      height: 20px;
      background: #ffffff;
      border: var(--lineW) solid var(--line);
      border-radius: 8px;
      pointer-events: none;
    }

    .wheel-obstruction.left { left: 4px; }
    .wheel-obstruction.right { right: 4px; }

    .avoid-wheels .tile-area {
      padding-bottom: 26px;
    }

    .notes-area {
      margin-top: 14px;
      display: grid;
      gap: 12px;
    }

    .notes-block {
      display: grid;
      gap: 4px;
    }

    .notes-label {
      font-weight: 700;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      min-height: 90px;
      resize: vertical;
      border-radius: 8px;
      border: 1px solid #c9cdd3;
      padding: 8px 10px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background: #fff;
      -webkit-user-select: text;
      user-select: text;
      touch-action: manipulation;
    }

    /* Van grid layouts */
    .sv-cabin, .sv-back {
      display: grid;
      grid-template-rows: 1fr 1fr;
    }
    .sv-cabin .row.top, .sv-back .row.top { grid-template-columns: repeat(3, 1fr); }
    .sv-cabin .row.bot, .sv-back .row.bot { grid-template-columns: repeat(2, 1fr); }

    .dv-wrap {
      display: grid;
      grid-template-columns: 1fr 2.2fr 1fr;
      gap: 10px;
      align-items: stretch;
    }

    .dv-stack {
      border: var(--lineW) solid var(--line);
      background: #fff;
      display: grid;
      grid-template-rows: 1fr 1fr;
    }

    .dv-centre {
      border: var(--lineW) solid var(--line);
      background: #fff;
      display: grid;
      grid-template-rows: 1fr 1.35fr;
    }

    .dv-centre .row.top {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
    }

    .dv-centre .row.bot {
      display: grid;
      grid-template-columns: 1fr;
    }

    /* Drag clone â€” NO transform scale/rotate (causes visual jump) */
    .is-dragging {
      position: fixed;
      z-index: 9999 !important;
      pointer-events: none;
      opacity: 0.85;
      box-shadow: 0 12px 28px rgba(0,0,0,0.3);
      touch-action: none;
      /* No transform - it causes visual position shift */
    }

    /* ============ RESPONSIVE BREAKPOINTS ============ */

    @media (max-width: 768px) {
      .two-cols { 
        grid-template-columns: 1fr; 
        gap: 14px;
      }
      .dv-wrap { 
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .dv-wrap .section:nth-child(2) {
        grid-column: 1 / -1;
        order: -1;
      }
      .box { min-height: 70px; }
      .card-title { font-size: 14px; }
    }

    @media (max-width: 500px) {
      .page { padding: 8px; gap: 8px; }
      .topbar { padding: 10px; gap: 8px; }
      .controls { gap: 6px; }
      .controls input[type="text"] { flex: 1 1 100%; font-size: 16px; }
      .controls button {
        flex: 1;
        min-width: calc(50% - 4px);
        padding: 10px 8px;
        font-size: 12px;
      }
      .dv-wrap { grid-template-columns: 1fr; gap: 10px; }
      .dv-wrap .section:nth-child(2) { order: 0; }
      .box { min-height: 65px; }
      .box-layout { grid-template-rows: 20px 1fr; gap: 3px; padding: 2px; }
      .stop-input { width: 32px; min-width: 32px; height: 18px; font-size: 10px; }
      .route-select { height: 18px; font-size: 9px; }
      .tile { min-width: 70px; min-height: 34px; }
      .title-centre { font-size: 15px; }
      .section-head .label { font-size: 12px; }
      #bin { width: 44px; min-width: 44px; font-size: 20px; }
      .wheel-obstruction { width: 26px; height: 16px; bottom: 2px; }
      .wheel-obstruction.left { left: 3px; }
      .wheel-obstruction.right { right: 3px; }
      .avoid-wheels .tile-area { padding-bottom: 22px; }
    }

    @media (max-width: 360px) {
      .sv-cabin .row.top, .sv-back .row.top { grid-template-columns: repeat(3, 1fr); }
      .box { min-height: 60px; }
      .route-select { font-size: 8px; }
    }

    @media (max-height: 500px) and (orientation: landscape) {
      .two-cols { grid-template-columns: 1fr 1fr; }
      .dv-wrap { grid-template-columns: 1fr 2fr 1fr; }
      .dv-wrap .section:nth-child(2) { order: 0; grid-column: auto; }
      .box { min-height: 60px; }
      .notes-area { grid-template-columns: 1fr 1fr; }
      textarea { min-height: 70px; }
    }
  </style>
</head>

<body>
  <div class="page" id="app">
    <div class="topbar">
      <div class="controls">
        <input id="tileText" type="text" placeholder="Dog name..." />
        <button id="addTileBtn" type="button">Add Dog</button>
        <button id="clearBtn" class="btn-danger" type="button">Clear All</button>
      </div>
      <div class="tray-area">
        <div class="tiles-tray" id="tray" aria-label="Tiles tray"></div>
        <div id="bin">ðŸ—‘</div>
      </div>
      <div class="hint">Drag tiles into boxes. Double-tap to edit. Drag to bin to delete.</div>
    </div>

    <div class="layout-card" id="printArea">
      <div class="title-centre">Half Day Route</div>

      <div class="van-section">
        <div class="card-title">Small Van SV</div>
        <div class="two-cols">
          <div class="section">
            <div class="section-head"><div class="label">Cabin</div></div>
            <div class="kennel-grid sv-cabin">
              <div class="row top">
                <div class="box" data-cap="2" data-box="sv-cabin-top-1"></div>
                <div class="box" data-cap="2" data-box="sv-cabin-top-2"></div>
                <div class="box" data-cap="2" data-box="sv-cabin-top-3"></div>
              </div>
              <div class="row bot">
                <div class="box" data-cap="2" data-box="sv-cabin-bot-1"></div>
                <div class="box" data-cap="2" data-box="sv-cabin-bot-2"></div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-head"><div class="label">Back</div></div>
            <div class="kennel-grid sv-back">
              <div class="row top">
                <div class="box" data-cap="2" data-box="sv-back-top-1"></div>
                <div class="box" data-cap="2" data-box="sv-back-top-2"></div>
                <div class="box" data-cap="2" data-box="sv-back-top-3"></div>
              </div>
              <div class="row bot">
                <div class="box avoid-wheels" data-cap="2" data-box="sv-back-bot-1" data-wheels="1"></div>
                <div class="box avoid-wheels" data-cap="2" data-box="sv-back-bot-2" data-wheels="1"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="van-section">
        <div class="card-title">Dispatch Van DV</div>
        <div class="dv-wrap">
          <div class="section">
            <div class="section-head"><div class="label">Left</div></div>
            <div class="dv-stack">
              <div class="box" data-cap="2" data-box="dv-left-top"></div>
              <div class="box" data-cap="2" data-box="dv-left-bot"></div>
            </div>
          </div>

          <div class="section">
            <div class="section-head"><div class="label">Centre</div></div>
            <div class="dv-centre">
              <div class="row top">
                <div class="box" data-cap="2" data-box="dv-back-top-1"></div>
                <div class="box" data-cap="2" data-box="dv-back-top-2"></div>
                <div class="box" data-cap="2" data-box="dv-back-top-3"></div>
              </div>
              <div class="row bot">
                <div class="box" data-cap="2" data-box="dv-back-bot-xl"></div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-head"><div class="label">Right</div></div>
            <div class="dv-stack">
              <div class="box" data-cap="2" data-box="dv-right-top"></div>
              <div class="box" data-cap="2" data-box="dv-right-bot"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="notes-area">
        <div class="notes-block">
          <div class="notes-label">Sequence and Notes</div>
          <textarea id="notesText" placeholder=""></textarea>
        </div>

        <div class="notes-block">
          <div class="notes-label">Intros</div>
          <textarea id="introsText" placeholder=""></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const tray = document.getElementById('tray');
      const bin = document.getElementById('bin');
      const input = document.getElementById('tileText');
      const addBtn = document.getElementById('addTileBtn');
      const clearBtn = document.getElementById('clearBtn');
      const notesText = document.getElementById('notesText');
      const introsText = document.getElementById('introsText');

      const STORAGE_KEY = 'half_day_route_v3';
      const ROUTE_OPTIONS = ['', 'S2H', 'H2S', 'D2S', 'S2S', 'PU', 'DO'];

      const state = {
        tiles: {},
        placements: {},
        boxMeta: {},
        notes: '',
        intros: ''
      };

      // ==================== PLATFORM DETECTION ====================
      const isAndroid = /Android/i.test(navigator.userAgent);

      const uid = () => 't_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);

      // ==================== PERSISTENCE ====================

      function save() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function load() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        try {
          const data = JSON.parse(raw);
          if (!data) return;
          state.tiles = data.tiles || {};
          state.placements = data.placements || {};
          state.boxMeta = data.boxMeta || {};
          state.notes = typeof data.notes === 'string' ? data.notes : '';
          state.intros = typeof data.intros === 'string' ? data.intros : '';
        } catch(e) {}
      }

      function clearAll() {
        state.tiles = {};
        state.placements = {};
        state.boxMeta = {};
        state.notes = '';
        state.intros = '';
        localStorage.removeItem(STORAGE_KEY);
        hydrate();
      }

      function ensureBoxMeta(boxId) {
        if (!state.boxMeta[boxId]) {
          state.boxMeta[boxId] = { stop: '', route: '' };
        }
        return state.boxMeta[boxId];
      }

      // ==================== DRAG & DROP STATE ====================
      let isDragging = false;
      let activeClone = null;
      let currentDragTile = null;
      let dragId = null;
      let startX = 0;
      let startY = 0;
      let lastTapTime = 0;
      let lastTapTileId = null;

      const MOVE_THRESHOLD = 10;

      // ==================== ANDROID TOUCH HANDLING ====================
      // PATTERN FROM WORKING VAN MANAGER:
      // 1. Single touchstart listener on document (passive: true)
      // 2. Passive touchmove (checkTouchScroll) to detect scrolling
      // 3. Non-passive touchmove ONLY during active drag
      // 4. NO body class changes (causes reflow/scroll jump)

      let touchStartPos = null;
      let dragSourceElement = null;
      let pendingDragInfo = null;
      let boundTouchMove = null;
      let boundTouchEnd = null;
      let longPressTimer = null;

      // Tuned settings from working reference
      const LONG_PRESS_DURATION = 180;
      const SCROLL_THRESHOLD = 10;

      // Store touch offset for smooth drag positioning
      let touchOffsetX = 0;
      let touchOffsetY = 0;

      // Handle touch start - DOCUMENT LEVEL
      function handleTouchStart(e) {
        if (e.touches.length !== 1) return; // Single touch only

        const touch = e.touches[0];
        // Find tile directly (entire tile is draggable)
        const tile = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.tile, .tile-inbox');
        if (!tile) return;

        // Get tile ID from data attribute
        const tid = tile.getAttribute('data-tile-id');
        if (!tid || !state.tiles[tid]) return;

        // Clean up any existing listeners first (prevents stacking)
        document.removeEventListener('touchmove', checkTouchScroll);
        document.removeEventListener('touchend', cancelTouchDrag);
        document.removeEventListener('touchcancel', cancelTouchDrag);
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }

        // Calculate offset from touch point to tile top-left (for smooth positioning)
        const tileRect = tile.getBoundingClientRect();
        touchOffsetX = touch.clientX - tileRect.left;
        touchOffsetY = touch.clientY - tileRect.top;

        touchStartPos = { x: touch.clientX, y: touch.clientY };
        dragSourceElement = tile;
        pendingDragInfo = {
          tile: tile,
          tid: tid,
          coords: { x: touch.clientX, y: touch.clientY },
          // CRITICAL: Store scroll position NOW before any changes
          scrollX: window.scrollX,
          scrollY: window.scrollY,
          // Store tile's viewport position for accurate clone placement
          tileRect: tileRect
        };

        // Immediate visual feedback
        tile.classList.add('touch-active');

        // Start long-press timer
        longPressTimer = setTimeout(() => {
          if (pendingDragInfo && touchStartPos) {
            startDragTouch(pendingDragInfo);
          }
        }, LONG_PRESS_DURATION);

        // Listen for movement/cancel (passive to allow scroll initially)
        document.addEventListener('touchmove', checkTouchScroll, { passive: true });
        document.addEventListener('touchend', cancelTouchDrag);
        document.addEventListener('touchcancel', cancelTouchDrag);
      }

      // Check if user is scrolling (passive - doesn't block scroll)
      function checkTouchScroll(e) {
        if (!touchStartPos || isDragging) return;

        const touch = e.touches[0];
        const dx = Math.abs(touch.clientX - touchStartPos.x);
        const dy = Math.abs(touch.clientY - touchStartPos.y);

        // If moved too much before timer, it's a scroll - cancel drag
        if (dx > SCROLL_THRESHOLD || dy > SCROLL_THRESHOLD) {
          cancelTouchDrag();
        }
      }

      // Cancel drag attempt (user scrolled or lifted finger)
      function cancelTouchDrag() {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }

        // Remove visual feedback
        if (dragSourceElement) {
          dragSourceElement.classList.remove('touch-active');
        }

        touchStartPos = null;
        pendingDragInfo = null;
        dragSourceElement = null;

        document.removeEventListener('touchmove', checkTouchScroll);
        document.removeEventListener('touchend', cancelTouchDrag);
        document.removeEventListener('touchcancel', cancelTouchDrag);
      }

      // Start actual drag (long-press completed)
      function startDragTouch(dragInfo) {
        // Remove the scroll-checking listeners
        document.removeEventListener('touchmove', checkTouchScroll);
        document.removeEventListener('touchend', cancelTouchDrag);
        document.removeEventListener('touchcancel', cancelTouchDrag);

        // Get stored scroll position from touchstart
        const savedScrollX = dragInfo.scrollX;
        const savedScrollY = dragInfo.scrollY;

        // Now we're dragging
        isDragging = true;
        dragId = dragInfo.tid;
        currentDragTile = dragInfo.tile;

        // NO body class change - even empty class can trigger reflow

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }

        // Visual feedback - transition from touch-active to long-press-active
        if (dragSourceElement) {
          dragSourceElement.classList.remove('touch-active');
          dragSourceElement.classList.add('long-press-active');
        }

        // Create clone - position at tile's current visual position
        // Use stored tileRect for consistent positioning
        createDragClone(dragInfo.tile, dragInfo.tileRect.left, dragInfo.tileRect.top);

        // CRITICAL: Restore scroll position immediately and after render
        window.scrollTo(savedScrollX, savedScrollY);
        requestAnimationFrame(() => {
          window.scrollTo(savedScrollX, savedScrollY);
        });

        // CRITICAL: Add NON-PASSIVE touchmove listener to block scrolling
        boundTouchMove = handleDragTouchMove;
        boundTouchEnd = handleDragTouchEnd;
        document.addEventListener('touchmove', boundTouchMove, { passive: false });
        document.addEventListener('touchend', boundTouchEnd);
        document.addEventListener('touchcancel', boundTouchEnd);
      }

      // Handle touch move DURING DRAG (non-passive)
      function handleDragTouchMove(e) {
        if (!isDragging) return;

        // CRITICAL: Prevent default to STOP scrolling
        e.preventDefault();

        const touch = e.touches[0];

        if (activeClone) {
          // Position clone relative to finger using saved offset
          activeClone.style.left = (touch.clientX - touchOffsetX) + 'px';
          activeClone.style.top = (touch.clientY - touchOffsetY) + 'px';
        }

        // Update drag-over states
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target) {
          const box = target.closest('.box');
          const binEl = target.closest('#bin');
          const trayEl = target.closest('#tray');
          if (box) box.classList.add('drag-over');
          if (binEl) binEl.classList.add('drag-over');
          if (trayEl) trayEl.classList.add('drag-over');
        }
      }

      // Handle touch end DURING DRAG
      function handleDragTouchEnd(e) {
        // Remove listeners
        document.removeEventListener('touchmove', boundTouchMove);
        document.removeEventListener('touchend', boundTouchEnd);
        document.removeEventListener('touchcancel', boundTouchEnd);

        // Get final position
        const touch = e.changedTouches[0];
        finishDrag(touch.clientX, touch.clientY);
      }

      // Setup Android touch events - DOCUMENT LEVEL
      if (isAndroid) {
        document.addEventListener('touchstart', handleTouchStart, { passive: true });
      }

      // ==================== HELPER FUNCTIONS ====================

      function createDragClone(tile, tileLeft, tileTop) {
        activeClone = tile.cloneNode(true);
        activeClone.classList.add('is-dragging');
        activeClone.classList.remove('touch-active', 'long-press-active');
        activeClone.style.width = Math.max(tile.offsetWidth, 80) + 'px';
        activeClone.style.height = Math.max(tile.offsetHeight, 38) + 'px';
        // Position clone exactly where tile is (using stored tileRect position)
        activeClone.style.left = tileLeft + 'px';
        activeClone.style.top = tileTop + 'px';
        document.body.appendChild(activeClone);
        tile.style.opacity = '0.3';
      }

      function finishDrag(clientX, clientY) {
        isDragging = false;

        // Clean up visual feedback
        if (dragSourceElement) {
          dragSourceElement.classList.remove('touch-active', 'long-press-active');
          dragSourceElement.style.opacity = '1';
        }
        if (currentDragTile) {
          currentDragTile.style.opacity = '1';
        }

        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        if (activeClone && dragId) {
          const target = document.elementFromPoint(clientX, clientY);
          const box = target?.closest('.box');
          const isBin = target?.closest('#bin');

          // Remove from all placements
          removeTileFromAllBoxes(dragId);

          if (isBin) {
            delete state.tiles[dragId];
          } else if (box) {
            placeTileInBox(dragId, box.dataset.box);
          }

          activeClone.remove();
          activeClone = null;
          save();
          hydrate();
        }

        // Reset all drag state
        currentDragTile = null;
        dragSourceElement = null;
        pendingDragInfo = null;
        touchStartPos = null;
        dragId = null;
      }

      function cancelDrag() {
        isDragging = false;

        if (dragSourceElement) {
          dragSourceElement.classList.remove('touch-active', 'long-press-active');
          dragSourceElement.style.opacity = '1';
        }
        if (currentDragTile) {
          currentDragTile.style.opacity = '1';
        }

        if (activeClone) {
          activeClone.remove();
          activeClone = null;
        }

        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        currentDragTile = null;
        dragSourceElement = null;
        pendingDragInfo = null;
        touchStartPos = null;
        dragId = null;
      }

      // ==================== WINDOWS/DESKTOP: Pointer events on WHOLE TILE ====================

      function wirePointerEvents(tile, tid) {
        // Set touch-action: none on tile for pointer capture to work
        tile.style.touchAction = 'none';

        tile.onpointerdown = function(e) {
          if (e.button !== 0) return;

          startX = e.clientX;
          startY = e.clientY;
          dragId = tid;
          currentDragTile = tile;

          // Calculate offset for smooth positioning
          const tileRect = tile.getBoundingClientRect();
          touchOffsetX = e.clientX - tileRect.left;
          touchOffsetY = e.clientY - tileRect.top;

          tile.setPointerCapture(e.pointerId);

          tile.onpointermove = function(m) {
            const dist = Math.abs(m.clientX - startX) + Math.abs(m.clientY - startY);
            if (dist > MOVE_THRESHOLD) {
              if (!activeClone) {
                isDragging = true;
                const currentRect = tile.getBoundingClientRect();
                createDragClone(tile, currentRect.left, currentRect.top);
              }
              // Move clone with finger using offset
              activeClone.style.left = (m.clientX - touchOffsetX) + 'px';
              activeClone.style.top = (m.clientY - touchOffsetY) + 'px';

              // Update drag-over states
              document.querySelectorAll('.drag-over').forEach(elem => elem.classList.remove('drag-over'));
              const target = document.elementFromPoint(m.clientX, m.clientY);
              if (target) {
                const box = target.closest('.box');
                const binEl = target.closest('#bin');
                const trayEl = target.closest('#tray');
                if (box) box.classList.add('drag-over');
                if (binEl) binEl.classList.add('drag-over');
                if (trayEl) trayEl.classList.add('drag-over');
              }
            }
          };

          tile.onpointerup = function(u) {
            tile.releasePointerCapture(u.pointerId);
            tile.onpointermove = null;
            tile.onpointerup = null;

            if (isDragging) {
              finishDrag(u.clientX, u.clientY);
            } else {
              tile.style.opacity = '1';
              currentDragTile = null;
            }
          };

          tile.onpointercancel = function() {
            cancelDrag();
          };
        };
      }

      // ==================== TILE PLACEMENT ====================

      function removeTileFromAllBoxes(tileId) {
        for (const boxId of Object.keys(state.placements)) {
          const arr = state.placements[boxId] || [];
          const filtered = arr.filter(id => id !== tileId);
          if (filtered.length === 0) {
            delete state.placements[boxId];
          } else {
            state.placements[boxId] = filtered;
          }
        }
      }

      function placeTileInBox(tileId, boxId) {
        if (!state.tiles[tileId]) return;
        const box = document.querySelector('.box[data-box="' + boxId + '"]');
        if (!box) return;
        const cap = Number(box.dataset.cap || '2');
        const list = state.placements[boxId] ? [...state.placements[boxId]] : [];
        if (list.includes(tileId)) return;
        if (list.length >= cap) return;
        list.push(tileId);
        state.placements[boxId] = list.slice(0, cap);
      }

      function editTile(tileId) {
        const tile = state.tiles[tileId];
        if (!tile) return;
        const next = prompt('Edit tile text:', tile.text);
        if (next === null) return;
        const trimmed = (next || '').trim();
        if (!trimmed) return;
        state.tiles[tileId].text = trimmed;
        save();
        hydrate();
      }

      // ==================== UI BUILDING ====================

      function buildBoxUI(box) {
        const boxId = box.dataset.box;
        box.innerHTML = '';

        const wrap = document.createElement('div');
        wrap.className = 'box-layout';

        const controls = document.createElement('div');
        controls.className = 'box-controls';

        const stop = document.createElement('input');
        stop.className = 'stop-input';
        stop.type = 'text';
        stop.inputMode = 'numeric';
        stop.placeholder = '#';
        stop.setAttribute('aria-label', 'Stop number');

        const route = document.createElement('select');
        route.className = 'route-select';
        route.setAttribute('aria-label', 'Route option');

        ROUTE_OPTIONS.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = v === '' ? 'â€”' : v;
          route.appendChild(opt);
        });

        const meta = ensureBoxMeta(boxId);
        stop.value = meta.stop || '';
        route.value = meta.route || '';

        stop.addEventListener('input', () => {
          const cleaned = stop.value.replace(/[^\d]/g, '').slice(0, 3);
          if (stop.value !== cleaned) stop.value = cleaned;
          ensureBoxMeta(boxId).stop = stop.value;
          save();
        });

        route.addEventListener('change', () => {
          ensureBoxMeta(boxId).route = route.value;
          save();
        });

        controls.appendChild(stop);
        controls.appendChild(route);

        const tileArea = document.createElement('div');
        tileArea.className = 'tile-area one';
        tileArea.dataset.boxId = boxId;

        if (box.dataset.wheels === '1') {
          const wl = document.createElement('div');
          wl.className = 'wheel-obstruction left';
          const wr = document.createElement('div');
          wr.className = 'wheel-obstruction right';
          tileArea.appendChild(wl);
          tileArea.appendChild(wr);
        }

        wrap.appendChild(controls);
        wrap.appendChild(tileArea);
        box.appendChild(wrap);

        return tileArea;
      }

      // ==================== CREATE TILE (Full tile draggable) ====================

      function createTileElement(tid, className) {
        const tile = document.createElement('div');
        tile.className = className;
        tile.textContent = state.tiles[tid].text;

        if (isAndroid) {
          // ANDROID: Mark tile as draggable (whole tile via long-press)
          tile.setAttribute('data-tile-id', tid);
          // Touch events handled at document level
        } else {
          // WINDOWS/DESKTOP: Pointer events on whole tile
          wirePointerEvents(tile, tid);
        }

        // Double-tap/click to edit
        tile.ondblclick = function() {
          editTile(tid);
        };

        return tile;
      }

      function createTrayTile(tile) {
        const el = createTileElement(tile.id, 'tile');
        tray.appendChild(el);
        requestAnimationFrame(() => fitText(el));
      }

      function createInboxTile(tileId, tileArea) {
        const tile = state.tiles[tileId];
        if (!tile) return null;
        const el = createTileElement(tileId, 'tile-inbox');
        tileArea.appendChild(el);
        requestAnimationFrame(() => fitText(el));
        return el;
      }

      function hydrate() {
        tray.innerHTML = '';
        notesText.value = state.notes || '';
        introsText.value = state.intros || '';

        document.querySelectorAll('.box').forEach(box => {
          const boxId = box.dataset.box;
          const tileArea = buildBoxUI(box);

          const list = (state.placements[boxId] || []).filter(id => state.tiles[id]).slice(0, 2);
          state.placements[boxId] = list;

          tileArea.classList.remove('one', 'two');
          tileArea.classList.add(list.length === 2 ? 'two' : 'one');

          list.forEach(id => createInboxTile(id, tileArea));
        });

        const placedIds = new Set();
        Object.values(state.placements).forEach(arr => {
          (arr || []).forEach(id => placedIds.add(id));
        });

        for (const tileId of Object.keys(state.tiles)) {
          if (!placedIds.has(tileId)) {
            createTrayTile(state.tiles[tileId]);
          }
        }
      }

      // ==================== TEXT FITTING ====================

      function fitText(node) {
        if (!node || !node.clientWidth || !node.clientHeight) return;

        let lo = 8, hi = 100, best = 12;

        while (lo <= hi) {
          const mid = Math.floor((lo + hi) / 2);
          node.style.fontSize = mid + 'px';

          if (node.scrollWidth <= (node.clientWidth - 6) && node.scrollHeight <= (node.clientHeight - 4)) {
            best = mid;
            lo = mid + 1;
          } else {
            hi = mid - 1;
          }
        }
        node.style.fontSize = best + 'px';
      }

      function refitAll() {
        document.querySelectorAll('.tile, .tile-inbox').forEach(n => fitText(n));
      }

      // ==================== NOTES HANDLING ====================

      function wireNotes() {
        const saveNow = () => {
          state.notes = notesText.value || '';
          state.intros = introsText.value || '';
          save();
        };

        notesText.addEventListener('input', () => {
          clearTimeout(window.__notesTimer);
          window.__notesTimer = setTimeout(saveNow, 150);
        });

        introsText.addEventListener('input', () => {
          clearTimeout(window.__introsTimer);
          window.__introsTimer = setTimeout(saveNow, 150);
        });
      }

      // ==================== EVENT LISTENERS ====================

      addBtn.addEventListener('click', () => {
        const text = (input.value || '').trim();
        if (!text) return;
        const id = uid();
        state.tiles[id] = { id, text };
        input.value = '';
        save();
        hydrate();
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addBtn.click();
      });

      clearBtn.addEventListener('click', () => {
        if (confirm('Clear all tiles, placements, and notes?')) {
          clearAll();
        }
      });

      // Escape key to cancel drag
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && activeClone) {
          cancelDrag();
        }
      });

      window.addEventListener('resize', () => {
        clearTimeout(window.__fitTimer);
        window.__fitTimer = setTimeout(refitAll, 80);
      });

      window.addEventListener('orientationchange', () => {
        setTimeout(refitAll, 200);
      });

      const ro = new ResizeObserver(() => {
        clearTimeout(window.__roTimer);
        window.__roTimer = setTimeout(refitAll, 50);
      });

      // ==================== INIT ====================

      load();
      wireNotes();
      hydrate();

      document.querySelectorAll('.box').forEach(b => ro.observe(b));
      ro.observe(tray);

      // Debug logging
      console.log('=== Half Day Route ===');
      console.log('User Agent:', navigator.userAgent);
      console.log('isAndroid:', isAndroid);
      if (isAndroid) {
        console.log('Mode: ANDROID - Full tile long-press drag');
        console.log('- Long-press tile for 180ms to start drag');
        console.log('- No body class changes (prevents reflow)');
        console.log('- Scroll position stored at touchstart, restored after clone');
      } else {
        console.log('Mode: WINDOWS/DESKTOP - Pointer events on whole tile');
        console.log('- Drag: Touch/click anywhere on tile');
      }

    })();
  </script>
</body>
</html>
